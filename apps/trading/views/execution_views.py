"""
Trading Execution Views - Order Placement and Position Management

This module contains views for executing trades and managing positions:
- Prepare manual trade execution with confirmation page
- Confirm and execute manual trade with broker
- Execute Nifty strangle orders in batches
- Calculate position sizing for futures and options

All views integrate with broker APIs (Breeze/Neo) for order placement.
"""

import logging
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.shortcuts import render, redirect
from django.contrib import messages
from django.utils import timezone
from apps.positions.models import Position

logger = logging.getLogger(__name__)


@login_required
@require_POST
def prepare_manual_execution(request):
    """
    Prepare manual trade execution - show confirmation page with 4-checkbox safety check.

    Receives trade data from manual_triggers.html and displays a confirmation page
    with comprehensive risk metrics and a 4-checkbox safety protocol:
    1. I have reviewed the trade analysis
    2. I understand the risk (max loss displayed)
    3. I have checked position size
    4. I confirm execution

    Request Body (POST form data):
        trade_data: JSON string containing complete trade details

    Trade Data Structure:
        {
            "algorithm_type": "futures"|"strangle"|"verify",
            "instrument": str,
            "entry_price": float,
            "stop_loss": float,
            "target": float,
            "quantity": int,
            "direction": "LONG"|"SHORT"|"NEUTRAL",
            "margin_required": float,
            "analysis_summary": str,
            "factors_met": [...]
        }

    Returns:
        HTML: Renders manual_execution_confirm.html with:
            - trade_data: Complete trade information
            - trade_data_json: JSON string for form submission
            - algorithm_display: Human-readable algorithm name
            - vix: Current India VIX
            - max_loss: Calculated maximum loss (entry - stop_loss) * quantity
            - risk_reward_ratio: Target reward / risk ratio
            - analysis_summary: Algorithm analysis summary

    Error Responses:
        - Redirects to manual_triggers with error message if:
          - Missing trade_data
          - Invalid JSON format
          - VIX fetch failure (uses last known value)

    Notes:
        - Does NOT place orders - only prepares confirmation
        - Risk metrics calculated for display
        - VIX fetched for market condition context
        - User must confirm via 4 checkboxes before execution
    """
    import json
    from decimal import Decimal
    from apps.brokers.integrations.breeze import get_india_vix

    try:
        # Get trade data from POST
        trade_data_json = request.POST.get('trade_data')
        if not trade_data_json:
            messages.error(request, "No trade data received")
            return redirect('trading:manual_triggers')

        trade_data = json.loads(trade_data_json)

        # Get current VIX
        vix = get_india_vix()

        # Determine algorithm display name
        algorithm_type = trade_data.get('algorithm_type', 'unknown')
        algorithm_display_map = {
            'futures': 'ICICI Futures Algorithm',
            'strangle': 'Nifty Strangle Generator',
            'verify': 'Verify Future Trade'
        }
        algorithm_display = algorithm_display_map.get(algorithm_type, algorithm_type)

        # Calculate risk metrics
        entry_price = Decimal(str(trade_data.get('entry_price', 0)))
        stop_loss = Decimal(str(trade_data.get('stop_loss', 0)))
        target = Decimal(str(trade_data.get('target', 0)))
        quantity = int(trade_data.get('quantity', 1))

        # Calculate max loss and risk:reward
        max_loss = abs(entry_price - stop_loss) * quantity
        max_gain = abs(target - entry_price) * quantity
        risk_reward_ratio = max_gain / max_loss if max_loss > 0 else Decimal('0')

        # Analysis summary
        analysis_summary = trade_data.get('analysis_summary',
            f"Trade generated by {algorithm_display} with {len(trade_data.get('factors_met', []))} factors validated")

        context = {
            'trade_data': trade_data,
            'trade_data_json': trade_data_json,
            'algorithm_display': algorithm_display,
            'vix': vix,
            'max_loss': max_loss,
            'risk_reward_ratio': risk_reward_ratio,
            'analysis_summary': analysis_summary,
        }

        return render(request, 'trading/manual_execution_confirm.html', context)

    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in trade data: {e}")
        messages.error(request, "Invalid trade data format")
        return redirect('trading:manual_triggers')

    except Exception as e:
        logger.error(f"Error preparing manual execution: {e}", exc_info=True)
        messages.error(request, f"Error: {str(e)}")
        return redirect('trading:manual_triggers')


@login_required
@require_POST
def confirm_manual_execution(request):
    """
    Execute manual trade after user confirms via 4-checkbox safety protocol.

    Places live orders with broker (Breeze for futures, Neo for options)
    and creates Position and Order records in database.

    Enforces ONE POSITION RULE: Only one open position allowed per broker account.

    Request Body (POST form data):
        trade_data: JSON string with complete trade details

    Broker Selection Logic:
        - algorithm_type == 'strangle' → Kotak Neo
        - algorithm_type == 'futures'|'verify' → ICICI Breeze

    Returns:
        Redirect:
            - Success: positions:position_detail with new position_id
            - Failure: trading:manual_triggers with error message

    Error Responses:
        - Missing trade_data → redirect with error
        - No active broker account → redirect with error
        - ONE POSITION RULE violated → redirect with error
        - Order placement failed → rollback transaction, redirect with error

    Side Effects:
        - Creates Position record with status='ACTIVE'
        - Places order with broker API
        - Creates Order record with broker_order_id
        - Transaction atomic: rollback on any failure
        - Logs all actions for audit trail
        - (TODO) Sends Telegram notification on success

    ONE POSITION RULE:
        Checks for existing positions with status='ACTIVE'
        Blocks new trade if existing position found
        User must close existing position before new trade

    Order Placement:
        ICICI Breeze:
            - Currently returns simulated order_id: MANUAL_{position_id}
            - TODO: Implement actual Breeze order placement API

        Kotak Neo:
            - Uses place_option_order() function
            - Supports Market (MKT) and Limit (L) orders
            - Product types: NRML, MIS, CNC
            - Real-time order placement via Neo API

    Notes:
        - Transaction.atomic() ensures all-or-nothing execution
        - Order status starts as 'PENDING', updated when filled
        - Position entry_price from trade_data, updated when order fills
        - Margin validated before order placement
        - Supports both LONG (BUY) and SHORT (SELL) directions
    """
    import json
    from decimal import Decimal
    from django.db import transaction

    from apps.orders.models import Order
    from apps.accounts.models import BrokerAccount
    from apps.brokers.integrations.breeze import get_breeze_client
    from apps.brokers.integrations.kotak_neo import get_kotak_client

    try:
        # Get trade data
        trade_data_json = request.POST.get('trade_data')
        if not trade_data_json:
            messages.error(request, "No trade data received")
            return redirect('trading:manual_triggers')

        trade_data = json.loads(trade_data_json)

        # Determine broker based on algorithm
        algorithm_type = trade_data.get('algorithm_type', 'futures')
        if algorithm_type == 'strangle':
            broker_code = 'KOTAK'
        else:
            broker_code = 'ICICI'

        # Get broker account
        try:
            broker_account = BrokerAccount.objects.get(broker=broker_code, is_active=True)
        except BrokerAccount.DoesNotExist:
            messages.error(request, f"No active {broker_code} broker account found")
            return redirect('trading:manual_triggers')

        # Check ONE POSITION RULE
        existing_positions = Position.objects.filter(
            account=broker_account,
            status='ACTIVE'
        )

        if existing_positions.exists():
            messages.error(request,
                f"Cannot execute: ONE POSITION RULE violated. "
                f"Close existing position first: {existing_positions.first().instrument}")
            return redirect('trading:manual_triggers')

        # Execute trade with transaction safety
        with transaction.atomic():
            # Prepare position data based on algorithm type
            instrument = trade_data.get('instrument', 'UNKNOWN')
            direction = trade_data.get('direction', 'LONG')
            quantity = int(trade_data.get('quantity', 1))
            lot_size = int(trade_data.get('lot_size', 1))
            entry_price = Decimal(str(trade_data.get('entry_price', 0)))
            margin_required = Decimal(str(trade_data.get('margin_required', 0)))

            # Stop-loss and target are optional
            stop_loss_value = trade_data.get('stop_loss')
            stop_loss = Decimal(str(stop_loss_value)) if stop_loss_value and stop_loss_value != 0 else None

            target_value = trade_data.get('target')
            target = Decimal(str(target_value)) if target_value and target_value != 0 else None

            # Strategy type based on algorithm
            strategy_type_map = {
                'futures': 'LLM_VALIDATED_FUTURES',
                'strangle': 'WEEKLY_NIFTY_STRANGLE',
                'verify': 'MANUAL_FUTURES_VERIFICATION'
            }
            strategy_type = strategy_type_map.get(algorithm_type, 'MANUAL_TRADE')

            # Get expiry date from trade data or use a default
            from datetime import datetime, timedelta
            expiry_str = trade_data.get('expiry_date')
            if expiry_str:
                expiry_date = datetime.strptime(expiry_str, '%Y-%m-%d').date()
            else:
                # Default to 30 days from now for futures
                expiry_date = (datetime.now() + timedelta(days=30)).date()

            # Create Position record
            position = Position.objects.create(
                account=broker_account,
                strategy_type=strategy_type,
                instrument=instrument,
                direction=direction,
                quantity=quantity,
                lot_size=lot_size,
                entry_price=entry_price,
                current_price=entry_price,
                stop_loss=stop_loss,
                target=target,
                expiry_date=expiry_date,
                margin_used=margin_required,
                entry_value=entry_price * quantity * lot_size,
                status='ACTIVE',
                notes=trade_data.get('analysis_summary', f'Manual {algorithm_type} trade execution')
            )

            logger.info(f"Created position {position.id} for manual trade")

            # Place order with broker
            try:
                if broker_code == 'ICICI':
                    # Place order with Breeze
                    breeze = get_breeze_client()
                    # Note: Actual order placement logic depends on Breeze API
                    # This is a placeholder - implement based on your broker API
                    order_result = {
                        'success': True,
                        'order_id': f'MANUAL_{position.id}',
                        'message': 'Order placed successfully (simulated)'
                    }
                else:
                    # Place order with Kotak Neo
                    from apps.brokers.integrations.kotak_neo import place_option_order

                    # Extract trading symbol from trade data
                    trading_symbol = trade_data.get('trading_symbol', trade_data.get('instrument'))

                    # Determine transaction type
                    transaction_type = 'B' if trade_data.get('direction') == 'LONG' else 'S'

                    # Get quantity
                    quantity = int(trade_data.get('quantity', 1))

                    # Get order parameters
                    product = trade_data.get('product', 'NRML')  # Default to NRML
                    order_type = trade_data.get('order_type', 'MKT')  # Default to Market
                    price = float(trade_data.get('limit_price', 0)) if order_type == 'L' else 0

                    logger.info(f"Placing Kotak Neo order: {trading_symbol} {transaction_type} {quantity}")

                    # Place actual order via Neo API
                    order_result = place_option_order(
                        trading_symbol=trading_symbol,
                        transaction_type=transaction_type,
                        quantity=quantity,
                        product=product,
                        order_type=order_type,
                        price=price
                    )

                # Check if order placement was successful
                if not order_result.get('success'):
                    error_msg = order_result.get('error', 'Order placement failed')
                    logger.error(f"Order placement failed: {error_msg}")
                    raise Exception(f"Broker order failed: {error_msg}")

                # Create Order record
                order = Order.objects.create(
                    position=position,
                    order_type='MARKET' if order_type == 'MKT' else 'LIMIT',
                    action='BUY' if trade_data.get('direction') == 'LONG' else 'SELL',
                    quantity=position.quantity,
                    price=position.entry_price,
                    status='PENDING',  # Will be updated when order is confirmed
                    broker_order_id=order_result.get('order_id'),
                    filled_quantity=0,  # Will be updated after order fills
                    filled_price=0  # Will be updated after order fills
                )

                logger.info(f"Created order {order.id} for position {position.id}")

                messages.success(request,
                    f"Trade executed successfully! Position ID: {position.id}, Order ID: {order.broker_order_id}")

                # TODO: Send Telegram notification

                return redirect('positions:position_detail', position_id=position.id)

            except Exception as broker_error:
                logger.error(f"Broker order failed: {broker_error}", exc_info=True)
                # Rollback will happen automatically due to transaction.atomic()
                messages.error(request, f"Order placement failed: {str(broker_error)}")
                return redirect('trading:manual_triggers')

    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in trade data: {e}")
        messages.error(request, "Invalid trade data format")
        return redirect('trading:manual_triggers')

    except Exception as e:
        logger.error(f"Error confirming manual execution: {e}", exc_info=True)
        messages.error(request, f"Execution error: {str(e)}")
        return redirect('trading:manual_triggers')


@login_required
@require_POST
def execute_strangle_orders(request):
    """
    Execute Nifty Strangle orders in batches via Kotak Neo API.

    Places strangle orders (Call SELL + Put SELL) in batches of 20 lots
    with 20-second delays between batches to comply with Neo API rate limits.

    Batch Execution Logic:
        - Max 20 lots per order (Neo API limit)
        - 20 second delay between batches
        - Sequential execution (not parallel)
        - Continues even if some batches fail
        - Returns detailed batch-by-batch results

    Request Body (JSON):
        {
            "suggestion_id": int,  # TradeSuggestion record ID
            "total_lots": int      # Total lots to execute (will be split into batches)
        }

    Returns:
        JsonResponse: {
            'success': bool,  # True if all batches succeeded
            'message': str,   # Summary: "X/Y batches completed"
            'batch_result': {
                'success': bool,
                'batches_completed': int,
                'total_batches': int,
                'call_orders': [...],  # List of call order results
                'put_orders': [...],   # List of put order results
                'errors': [...]        # Any errors encountered
            },
            'call_symbol': str,  # e.g., "NIFTY25NOV24500CE"
            'put_symbol': str,   # e.g., "NIFTY25NOV24400PE"
            'total_lots': int
        }

    Error Responses:
        - 400: Missing suggestion_id or total_lots
        - 404: Trade suggestion not found
        - 400: Suggestion not for Kotak Strangle strategy
        - 404: No active Kotak broker account
        - 500: Order placement error

    Side Effects:
        - Places multiple orders with Kotak Neo API
        - Creates Position record if all orders successful
        - Updates TradeSuggestion status to 'TAKEN'
        - Logs each batch execution
        - Transaction atomic for Position/Order creation

    Symbol Format:
        NIFTY<YY><MMM><STRIKE><CE/PE>
        Example: NIFTY25NOV24500CE
        - YY: Year (25 = 2025)
        - MMM: Month (NOV)
        - STRIKE: Strike price (24500)
        - CE/PE: Call or Put

    Position Record:
        - instrument: 'NIFTY_STRANGLE'
        - direction: 'NEUTRAL'
        - quantity: total_lots * 50 (NIFTY lot size)
        - entry_price: total_premium received
        - target: 50% of premium (half profit target)
        - stop_loss: 0 (managed separately)
        - margin_used: margin_required * total_lots

    Neo API Rate Limits:
        - 20 lots max per order
        - 20 second minimum delay between orders
        - This function handles batching automatically

    Notes:
        - NIFTY lot size hardcoded: 50
        - Product type: NRML (delivery)
        - Transaction type: S (SELL for short strangle)
        - Partial fills NOT supported - all-or-nothing per batch
        - Position created only after ALL batches succeed
    """
    import json
    from decimal import Decimal
    from django.db import transaction
    from apps.trading.models import TradeSuggestion
    from apps.brokers.integrations.kotak_neo import place_strangle_orders_in_batches
    from apps.positions.models import Position
    from apps.accounts.models import BrokerAccount
    from apps.orders.models import Order

    try:
        # Parse JSON body (frontend sends JSON, not form data)
        try:
            data = json.loads(request.body.decode('utf-8'))
            logger.info(f"Parsed request data: {data}")
        except Exception as parse_error:
            logger.error(f"Failed to parse JSON body: {parse_error}")
            logger.error(f"Request body: {request.body}")
            return JsonResponse({
                'success': False,
                'error': f'Invalid JSON data: {str(parse_error)}'
            })

        suggestion_id = data.get('suggestion_id')
        total_lots_raw = data.get('total_lots', 0)

        logger.info(f"Extracted values - suggestion_id: {suggestion_id}, total_lots: {total_lots_raw}")

        try:
            total_lots = int(total_lots_raw) if total_lots_raw else 0
        except (ValueError, TypeError) as e:
            logger.error(f"Invalid total_lots value: {total_lots_raw}, error: {e}")
            total_lots = 0

        if not suggestion_id or total_lots <= 0:
            logger.warning(f"Validation failed - suggestion_id: {suggestion_id}, total_lots: {total_lots}")
            return JsonResponse({
                'success': False,
                'error': 'suggestion_id and total_lots are required'
            })

        # CRITICAL: Get suggestion with FRESH data from database (no cache)
        # This is essential because user may have edited strikes/lots in the UI
        suggestion = TradeSuggestion.objects.filter(
            id=suggestion_id,
            user=request.user
        ).first()

        if not suggestion:
            return JsonResponse({
                'success': False,
                'error': 'Trade suggestion not found'
            })

        # CRITICAL: Refresh from database to ensure we have LATEST edited values
        # This bypasses any Django ORM caching
        suggestion.refresh_from_db()

        # Log the ACTUAL values we're using for order placement
        logger.info("="*80)
        logger.info(f"[CRITICAL ORDER CHECK] Suggestion #{suggestion_id}")
        logger.info(f"[CRITICAL ORDER CHECK] Call Strike from DB: {suggestion.call_strike}")
        logger.info(f"[CRITICAL ORDER CHECK] Put Strike from DB: {suggestion.put_strike}")
        logger.info(f"[CRITICAL ORDER CHECK] Call Premium from DB: {suggestion.call_premium}")
        logger.info(f"[CRITICAL ORDER CHECK] Put Premium from DB: {suggestion.put_premium}")
        logger.info(f"[CRITICAL ORDER CHECK] Total Lots from DB: {total_lots}")
        logger.info(f"[CRITICAL ORDER CHECK] Expiry from DB: {suggestion.expiry_date}")
        logger.info("="*80)

        # Validate suggestion is for strangle strategy
        if suggestion.strategy != 'kotak_strangle':
            return JsonResponse({
                'success': False,
                'error': 'This endpoint only handles Kotak Strangle suggestions'
            })

        # Get position details
        position_details = suggestion.position_details

        # Get broker account
        broker_account = BrokerAccount.objects.filter(
            broker='KOTAK',
            is_active=True
        ).first()

        if not broker_account:
            return JsonResponse({
                'success': False,
                'error': 'No active Kotak broker account found'
            })

        # Build call and put symbols from suggestion
        # NSE Format: NIFTY<DD><MMM><STRIKE><CE/PE>
        # Example: NIFTY25NOV24500CE = November 25th (DAY 25, not year 25!)
        # CRITICAL: Use %d%b (day + month), NOT %y%b (year + month)
        expiry_date = suggestion.expiry_date
        expiry_str = expiry_date.strftime('%d%b').upper()  # e.g., 02DEC for Dec 2nd

        # CRITICAL: Use FRESH database values for strikes
        call_strike = int(suggestion.call_strike)
        put_strike = int(suggestion.put_strike)

        # Build Breeze-style symbols (from option chain data)
        breeze_call_symbol = f"NIFTY{expiry_str}{call_strike}CE"
        breeze_put_symbol = f"NIFTY{expiry_str}{put_strike}PE"

        logger.info(f"[BREEZE SYMBOLS] Call: {breeze_call_symbol}, Put: {breeze_put_symbol}, Lots: {total_lots}")

        # CRITICAL: Map Breeze symbols to Neo symbols before placing orders
        from apps.brokers.integrations.kotak_neo import map_breeze_symbol_to_neo

        logger.info(f"[SYMBOL MAPPING] Mapping Breeze symbols to Neo format...")

        # Map CALL symbol
        call_mapping = map_breeze_symbol_to_neo(breeze_call_symbol, expiry_date=expiry_date)
        if not call_mapping['success']:
            logger.error(f"Failed to map CALL symbol: {call_mapping['error']}")
            return JsonResponse({
                'success': False,
                'error': f"Failed to map CALL symbol {breeze_call_symbol}: {call_mapping['error']}"
            })

        # Map PUT symbol
        put_mapping = map_breeze_symbol_to_neo(breeze_put_symbol, expiry_date=expiry_date)
        if not put_mapping['success']:
            logger.error(f"Failed to map PUT symbol: {put_mapping['error']}")
            return JsonResponse({
                'success': False,
                'error': f"Failed to map PUT symbol {breeze_put_symbol}: {put_mapping['error']}"
            })

        # Use Neo symbols for order placement
        neo_call_symbol = call_mapping['neo_symbol']
        neo_put_symbol = put_mapping['neo_symbol']
        lot_size = call_mapping['lot_size']  # Use lot size from Neo (should be same for both)

        logger.info(f"[NEO SYMBOLS] Call: {neo_call_symbol}, Put: {neo_put_symbol}, Lot Size: {lot_size}")

        # Place orders in batches (max 20 lots per order, 20 sec delays - Neo API limits)
        batch_result = place_strangle_orders_in_batches(
            call_symbol=neo_call_symbol,
            put_symbol=neo_put_symbol,
            total_lots=total_lots,
            batch_size=20,
            delay_seconds=20,
            product='NRML'
        )

        # Create Position and Order records if successful
        if batch_result['success']:
            with transaction.atomic():
                # Create position
                # Use lot_size from Neo mapping (already fetched above)
                total_quantity = total_lots * lot_size

                position = Position.objects.create(
                    account=broker_account,
                    strategy_type='WEEKLY_NIFTY_STRANGLE',
                    instrument='NIFTY',
                    direction='NEUTRAL',
                    quantity=total_lots,
                    lot_size=lot_size,
                    entry_price=suggestion.total_premium,
                    current_price=suggestion.total_premium,
                    # stop_loss and target are optional - not set for strangles
                    call_strike=call_strike,
                    put_strike=put_strike,
                    call_premium=suggestion.call_premium,
                    put_premium=suggestion.put_premium,
                    premium_collected=suggestion.total_premium,
                    expiry_date=suggestion.expiry_date,
                    margin_used=suggestion.margin_required * total_lots,
                    entry_value=suggestion.total_premium * total_quantity,
                    status='ACTIVE',
                    notes=f"Strangle: CE {call_strike} @ {suggestion.call_premium} + PE {put_strike} @ {suggestion.put_premium}"
                )

                # Update suggestion status
                suggestion.status = 'TAKEN'
                suggestion.taken_timestamp = timezone.now()
                suggestion.save()

                logger.info(f"Created position {position.id} for strangle execution")

        return JsonResponse({
            'success': batch_result['success'],
            'message': f"Strangle orders executed: {batch_result['batches_completed']}/{batch_result['total_batches']} batches",
            'batch_result': batch_result,
            'breeze_call_symbol': breeze_call_symbol,
            'breeze_put_symbol': breeze_put_symbol,
            'neo_call_symbol': neo_call_symbol,
            'neo_put_symbol': neo_put_symbol,
            'lot_size': lot_size,
            'total_lots': total_lots
        })

    except Exception as e:
        logger.error(f"Error executing strangle orders: {e}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        })


@login_required
@require_POST
def calculate_position_sizing(request):
    """
    Calculate position sizing for a trade based on available margin.

    Supports both futures and options with different calculation methods:
    - Futures: Based on margin per lot from Breeze API
    - Options: Based on premium and margin from Neo API

    Calculates recommended lots using risk management rules:
    - 50% margin rule for initial position
    - Remaining 50% reserved for averaging
    - Includes 3-stage averaging plan

    Request Body (JSON):
        Common Fields:
            {
                "instrument_type": "FUTURES"|"OPTIONS",
                "symbol": str,
                "direction": "LONG"|"SHORT",
                "entry_price": float,
                "stop_loss": float,
                "target": float,
                "lot_size": int
            }

        FUTURES Additional Fields:
            None required

        OPTIONS Additional Fields:
            {
                "strike": int,
                "option_type": "CE"|"PE",
                "premium": float,
                "stop_loss_premium": float,
                "target_premium": float,
                "strategy": "BUY"|"SELL"
            }

    Returns:
        JsonResponse: {
            'success': bool,
            'position_size_id': int,  # PositionSize record ID
            'result': {
                'recommended_lots': int,
                'total_quantity': int,
                'margin_required': float,
                'available_margin': float,
                'margin_per_lot': float,
                'margin_utilization_pct': float,
                'max_loss': float,
                'max_profit': float,
                'risk_reward_ratio': float,
                'averaging_down': {
                    'stage_1': {...},  # Initial position (33%)
                    'stage_2': {...},  # First averaging (33%)
                    'stage_3': {...}   # Final defense (34%)
                }
            }
        }

    Error Responses:
        - 400: Missing required parameters
        - 400: Invalid instrument_type
        - 401: Breeze/Neo authentication required
        - 500: Calculation error

    Side Effects:
        - Fetches margin data from Breeze (futures) or Neo (options) API
        - Creates PositionSize record in database
        - Record expires in 24 hours
        - Logs calculation details

    Position Sizing Logic:

        FUTURES (Breeze API):
            1. Fetch available F&O margin from Breeze
            2. Get margin per lot for specific contract
            3. Calculate: recommended_lots = (available_margin * 0.5) / margin_per_lot
            4. Min lots: 1, Max lots: available_margin / margin_per_lot
            5. Includes 3-stage averaging plan

        OPTIONS (Neo API):
            1. Fetch available margin from Neo
            2. Calculate margin per lot based on premium and strategy
            3. For SELL: margin = strike * lot_size * 0.15 (approx)
            4. For BUY: margin = premium * lot_size (full premium)
            5. Calculate recommended lots same as futures
            6. Includes different averaging logic for options

    Averaging Strategy:
        Stage 1 (Initial): 33% of recommended lots
        Stage 2 (Defense): 33% if price moves against
        Stage 3 (Final):   34% final defense position
        Total: 100% = Full recommended position

    Notes:
        - PositionSize record saved for 24 hours
        - User can retrieve via position_size_id for execution
        - Margin source indicated: 'breeze' or 'neo'
        - Risk/reward ratio calculated automatically
        - Max loss/profit based on stop loss/target
    """
    import json
    from apps.trading.services.position_sizer import PositionSizer
    from apps.trading.models import PositionSize
    from decimal import Decimal
    from datetime import timedelta

    try:
        body = json.loads(request.body)

        instrument_type = body.get('instrument_type')  # 'FUTURES' or 'OPTIONS'
        symbol = body.get('symbol')
        direction = body.get('direction', 'LONG')
        entry_price = Decimal(str(body.get('entry_price', 0)))
        stop_loss = Decimal(str(body.get('stop_loss', 0)))
        target = Decimal(str(body.get('target', 0)))
        lot_size = int(body.get('lot_size', 0))

        if not all([instrument_type, symbol, entry_price, stop_loss, target, lot_size]):
            return JsonResponse({
                'success': False,
                'error': 'Missing required parameters'
            })

        sizer = PositionSizer(request.user)

        if instrument_type == 'FUTURES':
            # Calculate futures position sizing
            result = sizer.calculate_futures_position_size(
                symbol=symbol,
                entry_price=entry_price,
                stop_loss=stop_loss,
                target=target,
                lot_size=lot_size,
                direction=direction
            )

            # Save to database
            position_size = PositionSize.objects.create(
                user=request.user,
                instrument_type='FUTURES',
                symbol=symbol,
                direction=direction,
                entry_price=entry_price,
                stop_loss=stop_loss,
                target=target,
                lot_size=lot_size,
                available_margin=Decimal(str(result['available_margin'])),
                margin_per_lot=Decimal(str(result['margin_per_lot'])),
                margin_source='breeze',
                recommended_lots=result['recommended_lots'],
                total_quantity=result['total_quantity'],
                margin_required=Decimal(str(result['margin_required'])),
                max_loss=Decimal(str(result['max_loss'])),
                max_profit=Decimal(str(result['max_profit'])),
                risk_reward_ratio=Decimal(str(result['risk_reward_ratio'])),
                averaging_data=result['averaging_down'],
                calculation_details=result,
                expires_at=timezone.now() + timedelta(hours=24)
            )

        elif instrument_type == 'OPTIONS':
            # Extract options-specific params
            strike = int(body.get('strike', 0))
            option_type = body.get('option_type', 'CE')
            premium = Decimal(str(body.get('premium', 0)))
            stop_loss_premium = Decimal(str(body.get('stop_loss_premium', 0)))
            target_premium = Decimal(str(body.get('target_premium', 0)))
            strategy = body.get('strategy', 'BUY')

            # Calculate options position sizing
            result = sizer.calculate_options_position_size(
                symbol=symbol,
                strike=strike,
                option_type=option_type,
                premium=premium,
                lot_size=lot_size,
                stop_loss_premium=stop_loss_premium,
                target_premium=target_premium,
                strategy=strategy
            )

            # Save to database
            position_size = PositionSize.objects.create(
                user=request.user,
                instrument_type='OPTIONS',
                symbol=symbol,
                direction=direction,
                entry_price=premium,
                stop_loss=stop_loss_premium,
                target=target_premium,
                lot_size=lot_size,
                strike=strike,
                option_type=option_type,
                available_margin=Decimal(str(result['available_margin'])),
                margin_per_lot=Decimal(str(result['margin_per_lot'])),
                margin_source='neo',
                recommended_lots=result['recommended_lots'],
                total_quantity=result['total_quantity'],
                margin_required=Decimal(str(result['margin_required'])),
                max_loss=Decimal(str(result['max_loss'])),
                max_profit=Decimal(str(result['max_profit'])),
                risk_reward_ratio=Decimal(str(result['risk_reward_ratio'])),
                calculation_details=result,
                expires_at=timezone.now() + timedelta(hours=24)
            )

        else:
            return JsonResponse({
                'success': False,
                'error': f'Invalid instrument type: {instrument_type}'
            })

        logger.info(f"Position sizing calculated for {symbol}: {result['recommended_lots']} lots")

        return JsonResponse({
            'success': True,
            'position_size_id': position_size.id,
            'result': result
        })

    except Exception as e:
        from apps.brokers.exceptions import BreezeAuthenticationError

        # Check if it's an authentication error
        if isinstance(e, BreezeAuthenticationError):
            logger.warning(f"Breeze authentication failed during position sizing: {e}")
            return JsonResponse({
                'success': False,
                'auth_required': True,
                'error': str(e),
                'message': 'Breeze session expired. Please re-login to continue.'
            })

        logger.error(f"Error calculating position sizing: {e}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        })
